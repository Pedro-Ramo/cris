<!doctype html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <title>Jornada Espacial Reorganizada — p5.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <script>
        // Jornada Espacial - Versão organizada
let nave;
let estrelas1 = [];
let estrelas2 = [];
let asteroides = [];
let projeteis = [];
let explosoes = [];
let escudos = [];
let projeteisChefe = []; // NOVO: Projéteis do chefe

let pontos = 0;
let vidas = 3;
let jogoAtivo = true;
let velocidadeAsteroide = 2.5;

let tempoEscudo = 0;
let escudoAtivo = false;

// Variáveis para o mecanismo de cooldown dos tiros
let ultimoTiro = 0;
let intervaloTiro = 15; // 15 frames = ~meio segundo de espera

// Variáveis para o sistema de munição
let tirosMaximos = 5;
let tirosDisponiveis = tirosMaximos;
let recarregando = false;
let tempoInicioRecarga = 0;
let tempoRecarga = 3000; // 3 segundos em milissegundos

// Variáveis para as estatísticas
let asteroidesDestruidos = 0;
let tempoInicioJogo;
let tempoFinalJogo;

// Variáveis para o sistema de níveis
let nivelAtual = 1;
let pontosParaProximoNivel = 200;

// Variável para o recorde de pontos
let recordePontos = 0;

// Variáveis para o tiro forte
let tirosParaTiroForte = 5;
let contadorTiroForte = 0;

// Variáveis do chefe
let chefe = null;
let pontoProximoChefe = 200;
let batalhaChefe = false;

function setup() {
    createCanvas(1503, 690);
    nave = new Nave();
    for (let i = 0; i < 50; i++) estrelas1.push(new Estrela(1));
    for (let i = 0; i < 50; i++) estrelas2.push(new Estrela(2));
    for (let i = 0; i < 4; i++) adicionarAsteroide();
    tempoInicioJogo = millis();
    
    // Carrega o recorde salvo no navegador
    let recordeSalvo = localStorage.getItem('recordePontos');
    if (recordeSalvo !== null) {
        recordePontos = int(recordeSalvo);
    }
}

function draw() {
    background(10); // espaço escuro

    // Camadas de estrelas para o efeito parallax
    for (let s of estrelas1) { s.update(); s.show(); }
    for (let s of estrelas2) { s.update(); s.show(); }

    if (jogoAtivo) {
        // Lógica principal do jogo
        nave.update();
        nave.show();
        
        if (chefe !== null) {
            chefe.update();
            chefe.show();
        }
        
        gerenciarObjetos();
        gerenciarPowerUps();
        gerenciarExplosoes();
        checarNivel();

        // Verifica se precisa recarregar
        if (tirosDisponiveis <= 0 && !recarregando) {
            recarregando = true;
            tempoInicioRecarga = millis();
        }
        // Verifica se a recarga terminou
        if (recarregando && millis() > tempoInicioRecarga + tempoRecarga) {
            tirosDisponiveis = tirosMaximos;
            recarregando = false;
        }

    } else {
        // Tela de Fim de Jogo
        textAlign(CENTER, CENTER);
        fill(255);
        textSize(36);
        text("FIM DE JOGO", width / 2, height / 2 - 80);
        textSize(24);
        
        // Exibe as estatísticas
        let tempoDecorrido = (tempoFinalJogo - tempoInicioJogo) / 1000;
        let minutos = floor(tempoDecorrido / 60);
        let segundos = floor(tempoDecorrido % 60);
        text("Estatísticas Finais:", width / 2, height / 2 - 10);
        text("Pontuação: " + pontos, width / 2, height / 2 + 20);
        text("Asteroides Destruídos: " + asteroidesDestruidos, width / 2, height / 2 + 50);
        text("Tempo de Sobrevivência: " + minutos + "m " + segundos + "s", width / 2, height / 2 + 80);
        
        // Exibe o recorde de pontuação
        text("Seu Recorde: " + recordePontos, width / 2, height / 2 + 110);
        
        textSize(18);
        text("Pressione R para reiniciar", width / 2, height / 2 + 150);
    }

    desenharHUD();
}

function keyPressed() {
    if (keyCode === UP_ARROW) {
        nave.acelerar();
    } 
    if (key === ' ') { 
        // Só permite atirar se tiver munição e o cooldown tiver passado
        if (tirosDisponiveis > 0 && frameCount > ultimoTiro + intervaloTiro) {
            // Verifica se é hora do tiro forte
            if (contadorTiroForte >= tirosParaTiroForte) {
                projeteis.push(new Projetil(nave.x + nave.tamanho, nave.y, 'forte'));
                contadorTiroForte = 0; // Reinicia o contador
            } else {
                projeteis.push(new Projetil(nave.x + nave.tamanho, nave.y, 'normal'));
                contadorTiroForte++;
            }
            ultimoTiro = frameCount; 
            tirosDisponiveis--;
        }
    } 
    if (key === 'R' || key === 'r') {
        reiniciar();
    }
}

function reiniciar() {
    pontos = 0;
    vidas = 3;
    asteroides = [];
    projeteis = [];
    explosoes = [];
    escudos = [];
    projeteisChefe = [];
    chefe = null;
    batalhaChefe = false;
    velocidadeAsteroide = 2.5;
    tempoEscudo = 0;
    escudoAtivo = false;
    ultimoTiro = 0;
    tirosDisponiveis = tirosMaximos;
    recarregando = false;
    
    // Reinicia as variáveis de estatística
    asteroidesDestruidos = 0;
    tempoInicioJogo = millis();

    // Reinicia as variáveis de nível
    nivelAtual = 1;
    pontosParaProximoNivel = 200;

    // Reinicia o contador do tiro forte
    contadorTiroForte = 0;
    pontoProximoChefe = 200;

    for (let i = 0; i < 4; i++) adicionarAsteroide();
    jogoAtivo = true;
    nave = new Nave();
}

/* --- Funções de Gerenciamento --- */

function gerenciarObjetos() {
    
    // Lógica de colisão da nave com asteroides
    for (let i = asteroides.length - 1; i >= 0; i--) {
        let a = asteroides[i];
        a.update();
        a.show();

        if (a.colidiuCom(nave)) {
            if (!escudoAtivo) {
                vidas--;
                explosoes.push(new Explosao(a.x, a.y));
                asteroides.splice(i, 1);
                if (vidas <= 0) {
                    jogoAtivo = false;
                    tempoFinalJogo = millis(); // Captura o tempo final
                    // Verifica e salva o novo recorde
                    if (pontos > recordePontos) {
                        recordePontos = pontos;
                        localStorage.setItem('recordePontos', recordePontos);
                    }
                } else {
                    adicionarAsteroide();
                }
            }
        }

        if (a.x < -a.r) {
            asteroides.splice(i, 1);
            pontos += 10;
            adicionarAsteroide();
        }
    }

    // Lógica de colisão para projéteis (normal e forte)
    for (let i = projeteis.length - 1; i >= 0; i--) {
        let p = projeteis[i];
        p.update();
        p.show();

        // Se o projetil já passou da tela, ele será removido
        if (p.x > width) {
            projeteis.splice(i, 1);
            continue;
        }
        
        // Verifica se o tiro forte está ativo para que não seja removido
        let tiroForteAtivado = p.tipo === 'forte';

        // Checa colisões
        for (let j = asteroides.length - 1; j >= 0; j--) {
            let a = asteroides[j];
            if (p.acertou(a)) {
                explosoes.push(new Explosao(a.x, a.y));
                pontos += 20;
                asteroidesDestruidos++;
                asteroides.splice(j, 1);
                adicionarAsteroide();

                // Se for um tiro normal, ele desaparece após o acerto
                if (!tiroForteAtivado) {
                    projeteis.splice(i, 1);
                    break; // Sai do loop de asteroides
                }
            }
        }

        // Se for um tiro forte, ele continua até sair da tela, atingindo múltiplos asteroides
        if (tiroForteAtivado) {
            if (p.x > width) {
                projeteis.splice(i, 1);
            }
        }
    }
    
    // Lógica do chefe
    if (batalhaChefe) {
        
        // Colisão dos projéteis da nave com o chefe
        for(let i = projeteis.length - 1; i >= 0; i--){
            let p = projeteis[i];
            if (p.acertou(chefe)) {
                chefe.vida--;
                projeteis.splice(i, 1);
                
                // Verifica se o chefe foi derrotado
                if (chefe.vida <= 0) {
                    explosoes.push(new Explosao(chefe.x, chefe.y, chefe.tamanho));
                    pontos += 100; // Bônus por derrotar o chefe
                    chefe = null;
                    batalhaChefe = false;
                    pontoProximoChefe += 200; // Configura o próximo chefe
                    for(let k = 0; k < 4; k++) adicionarAsteroide(); // Recomeça os asteroides
                    projeteisChefe = []; // Limpa os projéteis do chefe
                }
            }
        }
        
        // Colisão dos projéteis do chefe com a nave
        for (let i = projeteisChefe.length - 1; i >= 0; i--) {
            let p = projeteisChefe[i];
            p.update();
            p.show();
            if (p.colidiuCom(nave)) {
                if (!escudoAtivo) {
                    vidas--;
                    explosoes.push(new Explosao(p.x, p.y));
                    projeteisChefe.splice(i, 1);
                    if (vidas <= 0) {
                        jogoAtivo = false;
                        tempoFinalJogo = millis();
                        if (pontos > recordePontos) {
                            recordePontos = pontos;
                            localStorage.setItem('recordePontos', recordePontos);
                        }
                    }
                }
            }
            if (p.x < 0) {
                projeteisChefe.splice(i, 1);
            }
        }
    }
}

function gerenciarPowerUps() {
    // Adiciona um escudo aleatoriamente
    if (frameCount % 600 === 0) {
        escudos.push(new Escudo());
    }

    for (let i = escudos.length - 1; i >= 0; i--) {
        let e = escudos[i];
        e.update();
        e.show();
        if (e.colidiuCom(nave)) {
            escudoAtivo = true;
            tempoEscudo = frameCount;
            escudos.splice(i, 1);
        }
        if (e.x < -e.tamanho) {
            escudos.splice(i, 1);
        }
    }
    
    // Desativa o escudo após 5 segundos (300 frames)
    if (escudoAtivo && frameCount > tempoEscudo + 300) {
        escudoAtivo = false;
    }
}

function gerenciarExplosoes() {
    for (let i = explosoes.length - 1; i >= 0; i--) {
        explosoes[i].update();
        explosoes[i].show();
        if (explosoes[i].terminou()) {
            explosoes.splice(i, 1);
        }
    }
}

function checarNivel() {
    // Aumenta o nível e a velocidade
    if (pontos >= nivelAtual * pontosParaProximoNivel) {
        nivelAtual++;
        velocidadeAsteroide += 0.5;
    }
    
    // Verifica se é hora do chefe
    if (pontos >= pontoProximoChefe && chefe === null && !batalhaChefe) {
        batalhaChefe = true;
        asteroides = []; // Limpa os asteroides
        chefe = new Chefe(50); // Vida do chefe
    }
}

function adicionarAsteroide() {
    asteroides.push(new Asteroide(velocidadeAsteroide));
}

function desenharHUD() {
    fill(255);
    textSize(16);
    text("Pontos: " + pontos, 70, 30);
    
    // Exibe o nível e a progressão
    let textoNivel = "Fase: " + nivelAtual;
    text(textoNivel, 70, 70);
    
    let pontosRestantes = (nivelAtual * pontosParaProximoNivel) - pontos;
    text("Próxima Fase em: " + pontosRestantes + " pontos", 70, 90);
    
    // Exibe a quantidade de tiros
    let textoTiros = "Tiros: " + tirosDisponiveis + "/" + tirosMaximos;
    if (recarregando) {
        let tempoRestante = ceil((tempoInicioRecarga + tempoRecarga - millis()) / 1000);
        textoTiros = "Recarregando: " + tempoRestante + "s";
    }
    text(textoTiros, 70, 50);

    // Exibe o contador do tiro forte
    let tirosFaltantes = tirosParaTiroForte - contadorTiroForte;
    let textoTiroForte = "Tiro Forte em: " + tirosFaltantes;
    if (tirosFaltantes <= 0) {
        textoTiroForte = "Tiro Forte PRONTO!";
        fill(0, 255, 0); // Muda a cor para destacar
    }
    text(textoTiroForte, 70, 110);
    
    for (let i = 0; i < vidas; i++) {
        fill(255, 0, 0);
        heart(width - 40 - (i * 30), 30, 20);
    }
    
    // Barra de vida do chefe
    if (chefe !== null) {
        let barraVidaLargura = map(chefe.vida, 0, chefe.vidaTotal, 0, 200);
        noStroke();
        fill(50);
        rect(width / 2 - 100, 20, 200, 15);
        fill(255, 0, 0);
        rect(width / 2 - 100, 20, barraVidaLargura, 15);
    }
}

function heart(x, y, size) {
    beginShape();
    vertex(x, y);
    bezierVertex(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
    bezierVertex(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);
    endShape(CLOSE);
}

/* --- Classes --- */

class Nave {
    constructor() {
        this.x = 100;
        this.y = height / 2;
        this.vy = 0;
        this.tamanho = 30;
    }
    show() {
        push();
        translate(this.x, this.y);
        noStroke();
        
        // Design da nave
        if (escudoAtivo) {
            fill(100, 255, 255, 150);
            ellipse(0, 0, this.tamanho * 3, this.tamanho * 3);
        }

        // Corpo principal
        fill(150, 150, 150);
        beginShape();
        vertex(-this.tamanho, -this.tamanho/2);
        vertex(this.tamanho, 0);
        vertex(-this.tamanho, this.tamanho/2);
        endShape(CLOSE);
        
        // Cabine
        fill(255, 255, 255, 200);
        ellipse(0, 0, this.tamanho * 1.5, this.tamanho * 1.5);
        fill(100, 150, 255, 100);
        ellipse(0, 0, this.tamanho * 1.2, this.tamanho * 1.2);

        // Asas
        fill(200, 50, 50);
        triangle(-this.tamanho, -this.tamanho/2, -this.tamanho - 10, -this.tamanho, -this.tamanho, 0);
        triangle(-this.tamanho, this.tamanho/2, -this.tamanho - 10, this.tamanho, -this.tamanho, 0);

        // Propulsores
        fill(255, 200, 0);
        rect(-this.tamanho - 5, -5, 10, 10);
        pop();
    }
    update() {
        this.vy += 0.6;
        this.y += this.vy;
        this.y = constrain(this.y, 20, height - 20);
        if (this.y >= height - 20 || this.y <= 20) this.vy = 0;
    }
    acelerar() {
        this.vy = -9;
    }
}

class Projetil {
    constructor(x, y, tipo) {
        this.x = x;
        this.y = y;
        this.tipo = tipo;
        // ALTERADO: Aumentei o raio para o 'forte' para torná-lo visivelmente maior.
        this.r = (tipo === 'forte') ? 40 : 6; 
        this.speed = (tipo === 'forte') ? 6 : 7;
    }
    update() {
        this.x += this.speed;
    }
    show() {
        noStroke();
        if (this.tipo === 'forte') {
            // Design de tiro forte gigante que preenche a tela
            fill(255, 255, 0, 150);
            ellipse(this.x, this.y, this.r * 2);
            fill(255, 200, 0, 200);
            ellipse(this.x, this.y, this.r * 1.5);
            fill(255, 255, 255, 255);
            ellipse(this.x, this.y, this.r / 2);
        } else {
            // Design de laser normal
            fill(100, 200, 255);
            beginShape();
            vertex(this.x, this.y - 2);
            vertex(this.x + 20, this.y - 2);
            vertex(this.x + 25, this.y);
            vertex(this.x + 20, this.y + 2);
            vertex(this.x, this.y + 2);
            endShape(CLOSE);
        }
    }
    // ALTERADO: A função acertou para o tiro forte
    acertou(alvo) {
        let d = dist(this.x, this.y, alvo.x, alvo.y);
        
        if (this.tipo === 'forte') {
            // NOVO: Aumentei o "rangeColisaoForte" de 50 para 80 para garantir a colisão.
            let rangeColisaoForte = 80;
            return d < (this.r + alvo.r + rangeColisaoForte);
        } else {
            // Colisão normal para projéteis regulares
            return d < (this.r + alvo.r);
        }
    }
}

// Classe para o chefe
class Chefe {
    constructor(vida) {
        this.x = width - 100;
        this.y = height / 2;
        this.tamanho = 80;
        this.vidaTotal = vida;
        this.vida = vida;
        this.velocidadeY = 2;
        this.ultimoTiro = 0;
        this.intervaloTiro = 60; // 1 segundo
    }
    show() {
        push();
        translate(this.x, this.y);
        noStroke();
        fill(200, 50, 50);
        rectMode(CENTER);
        rect(0, 0, this.tamanho * 1.5, this.tamanho);
        fill(100, 100, 100);
        triangle(this.tamanho/2, -this.tamanho/2, this.tamanho*1.5, 0, this.tamanho/2, this.tamanho/2);
        pop();
    }
    update() {
        // Segue a nave
        if (this.y > nave.y) {
            this.y -= this.velocidadeY;
        } else {
            this.y += this.velocidadeY;
        }
        this.y = constrain(this.y, this.tamanho / 2, height - this.tamanho / 2);
        
        // Atira na nave
        if (frameCount > this.ultimoTiro + this.intervaloTiro) {
            projeteisChefe.push(new ProjetilChefe(this.x - this.tamanho / 2, this.y));
            this.ultimoTiro = frameCount;
        }
    }
    colidiuCom(nave) {
        let d = dist(this.x, this.y, nave.x, nave.y);
        return d < (this.tamanho * 0.8 + nave.tamanho * 0.8);
    }
}

// Classe para os projéteis do chefe
class ProjetilChefe {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = 10;
        this.speed = 5;
    }
    update() {
        this.x -= this.speed;
    }
    show() {
        noStroke();
        fill(255, 0, 0);
        ellipse(this.x, this.y, this.r * 2);
    }
    colidiuCom(nave) {
        let d = dist(this.x, this.y, nave.x, nave.y);
        return d < (this.r + nave.tamanho * 0.8);
    }
}

class Estrela {
    constructor(camada) {
        this.x = random(width);
        this.y = random(height);
        this.t = random(1, 3);
        this.camada = camada;
        this.speed = (this.camada === 1) ? random(0.5, 1.5) : random(2, 3.5);
    }
    update() {
        this.x -= this.speed;
        if (this.x < 0) {
            this.x = width;
            this.y = random(height);
        }
    }
    show() {
        noStroke();
        fill(255, this.camada === 1 ? 150 : 255);
        ellipse(this.x, this.y, this.t, this.t);
    }
}

class Asteroide {
    constructor(speed) {
        this.x = width + random(50, 200);
        this.y = random(40, height - 40);
        this.r = random(20, 50);
        this.speed = speed;
    }
    update() {
        this.x -= this.speed;
    }
    show() {
        noStroke();
        fill(150);
        ellipse(this.x, this.y, this.r * 2, this.r * 2);
    }
    colidiuCom(nave) {
        let d = dist(this.x, this.y, nave.x, nave.y);
        return d < (this.r + nave.tamanho * 0.8);
    }
}

class Escudo {
    constructor() {
        this.x = width + random(100, 400);
        this.y = random(50, height - 50);
        this.tamanho = 20;
        this.speed = 3;
    }
    update() {
        this.x -= this.speed;
    }
    show() {
        noFill();
        stroke(0, 255, 0);
        strokeWeight(3);
        ellipse(this.x, this.y, this.tamanho * 2);
        noStroke();
        fill(0, 255, 0, 80);
        ellipse(this.x, this.y, this.tamanho * 2, this.tamanho * 2);
    }
    colidiuCom(nave) {
        let d = dist(this.x, this.y, nave.x, nave.y);
        return d < (this.tamanho + nave.tamanho * 0.8);
    }
}

class Explosao {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.particulas = [];
        for (let i = 0; i < 15; i++) {
            this.particulas.push(new Particula(this.x, this.y));
        }
    }
    update() {
        for (let p of this.particulas) {
            p.update();
        }
    }
    show() {
        for (let p of this.particulas) {
            p.show();
        }
    }
    terminou() {
        return this.particulas.every(p => p.alpha <= 0);
    }
}

class Particula {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = random(-2, 2);
        this.vy = random(-2, 2);
        this.r = random(5, 15);
        this.alpha = 255;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= 5;
        this.r *= 0.95;
    }
    show() {
        noStroke();
        fill(255, this.alpha);
        ellipse(this.x, this.y, this.r);
    }
}
    </script>
</body>
</html>